// <auto-generated>
//  Purpose: Verifies retry logic survives transient SQL faults injected via Polly.Contrib.Simmy.
//  Whatâ€™s being validated: Customer adapter retries once when a timeout occurs and recovers gracefully.
//  Success: Method returns data after a simulated transient fault and logs remain clean (no leaked exceptions).
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using CRMAdapter.CommonConfig;
using CRMAdapter.CommonInfrastructure;
using CRMAdapter.Tests.TestUtilities.Fakes;
using CRMAdapter.Tests.TestUtilities.Helpers;
using CRMAdapter.VastOnline.Adapter;
using FluentAssertions;
using Polly;
using Polly.Contrib.Simmy;
using Polly.Contrib.Simmy.Outcomes;
using Xunit;

namespace CRMAdapter.Tests.ChaosTests;

public sealed class CustomerAdapter_Chaos_SQLTransientFaults
{
    [Fact]
    [Trait("Type", "Chaos")]
    public async Task GetById_ShouldRetry_WhenTransientTimeoutInjected()
    {
        // Arrange
        var fieldMap = MappingLoaderForTests.LoadFromEmbeddedResource("vastonline-test-mapping.json");
        var customerId = Guid.NewGuid();
        var chaosTriggered = 0;

        #pragma warning disable CS0618 // Simmy 0.3.0 exposes only obsolete overloads; suppress until library updates.
        var chaosPolicy = MonkeyPolicy.InjectFaultAsync(
            fault: (Exception)new TimeoutException("Simulated SQL timeout"),
            injectionRate: 1.0,
            enabled: (_, _) =>
            {
                var shouldInject = chaosTriggered == 0;
                if (shouldInject)
                {
                    chaosTriggered++;
                }

                return Task.FromResult(shouldInject);
            });
        #pragma warning restore CS0618

        var retryPolicy = Policy
            .Handle<TimeoutException>()
            .WaitAndRetryAsync(2, _ => TimeSpan.FromMilliseconds(10));

        var sqlRetryPolicy = new SimmySqlRetryPolicy(retryPolicy, chaosPolicy);

        using var connection = FakeDbConnectionFactory.Create(
            FakeDbConnectionFactory.Plan(
                "CustomerAdapter.GetById",
                new[]
                {
                    new Dictionary<string, object?>
                    {
                        ["Id"] = customerId,
                        ["Name"] = "Chaos Test",
                        ["Email"] = "chaos@example.com",
                        ["Phone"] = "+10000000000",
                        ["AddressLine1"] = "1 Chaos Way",
                        ["AddressLine2"] = string.Empty,
                        ["City"] = "Chaos",
                        ["State"] = "CT",
                        ["PostalCode"] = "12345",
                        ["Country"] = "US"
                    }
                }),
            FakeDbConnectionFactory.Plan(
                "CustomerAdapter.LoadVehicleReferences",
                Array.Empty<IDictionary<string, object?>>()));

        using var adapter = new CustomerAdapter(connection, fieldMap, sqlRetryPolicy);

        // Act
        var customer = await adapter.GetByIdAsync(customerId, CancellationToken.None);

        // Assert
        chaosTriggered.Should().Be(1, "Simmy should inject the fault exactly once");
        customer.Should().NotBeNull();
        customer!.DisplayName.Should().Be("Chaos Test");
    }

    private sealed class SimmySqlRetryPolicy : ISqlRetryPolicy
    {
        private readonly AsyncPolicy _retry;
        private readonly AsyncPolicy _chaos;

        public SimmySqlRetryPolicy(AsyncPolicy retry, AsyncPolicy chaos)
        {
            _retry = retry ?? throw new ArgumentNullException(nameof(retry));
            _chaos = chaos ?? throw new ArgumentNullException(nameof(chaos));
        }

        public Task<TResult> ExecuteAsync<TResult>(Func<CancellationToken, Task<TResult>> operation, CancellationToken cancellationToken)
        {
            if (operation is null)
            {
                throw new ArgumentNullException(nameof(operation));
            }

            return _retry.ExecuteAsync(async ct =>
            {
                TResult result = default!;
                await _chaos.ExecuteAsync(async innerCt =>
                {
                    result = await operation(innerCt).ConfigureAwait(false);
                }, ct).ConfigureAwait(false);

                return result;
            }, cancellationToken);
        }

        public Task ExecuteAsync(Func<CancellationToken, Task> operation, CancellationToken cancellationToken)
        {
            if (operation is null)
            {
                throw new ArgumentNullException(nameof(operation));
            }

            return _retry.ExecuteAsync(ct => _chaos.ExecuteAsync(operation, ct), cancellationToken);
        }
    }
}
