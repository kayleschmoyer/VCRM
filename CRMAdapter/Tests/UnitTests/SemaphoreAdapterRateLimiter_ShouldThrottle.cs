// <auto-generated>
//  Purpose: Exercises the semaphore-backed adapter rate limiter for secure defaults.
//  What is being validated: Ensures acquisitions block beyond the configured concurrency and invalid inputs are rejected.
//  Success: Second acquisition waits until release and constructor guards enforce positive limits and resource keys.
// </auto-generated>
#nullable enable
using System;
using System.Threading;
using System.Threading.Tasks;
using CRMAdapter.CommonInfrastructure;
using FluentAssertions;
using Xunit;

namespace CRMAdapter.Tests.UnitTests;

public sealed class SemaphoreAdapterRateLimiter_ShouldThrottle
{
    [Fact]
    [Trait("Type", "Unit")]
    public async Task AcquireAsync_ShouldBlock_WhenConcurrencyExceeded()
    {
        // Arrange
        var limiter = new SemaphoreAdapterRateLimiter(1);
        using var firstLease = await limiter.AcquireAsync("CustomerAdapter.GetById", CancellationToken.None);

        // Act
        var pendingLeaseTask = limiter.AcquireAsync("CustomerAdapter.GetById", CancellationToken.None);
        await Task.Delay(TimeSpan.FromMilliseconds(100));

        // Assert
        pendingLeaseTask.IsCompleted.Should().BeFalse();

        firstLease.Dispose();

        var completedTask = await Task.WhenAny(pendingLeaseTask, Task.Delay(TimeSpan.FromSeconds(1)));
        completedTask.Should().BeSameAs(pendingLeaseTask);

        using var secondLease = await pendingLeaseTask;
        secondLease.Should().NotBeNull();
    }

    [Theory]
    [Trait("Type", "Unit")]
    [InlineData(0)]
    [InlineData(-10)]
    public void Constructor_ShouldThrow_WhenConcurrencyNotPositive(int concurrency)
    {
        // Act
        Action action = () => new SemaphoreAdapterRateLimiter(concurrency);

        // Assert
        action.Should().Throw<ArgumentOutOfRangeException>();
    }

    [Theory]
    [Trait("Type", "Unit")]
    [InlineData("")]
    [InlineData(" ")]
    public async Task AcquireAsync_ShouldThrow_WhenResourceKeyInvalid(string resourceKey)
    {
        // Arrange
        var limiter = new SemaphoreAdapterRateLimiter(1);

        // Act
        var action = () => limiter.AcquireAsync(resourceKey, CancellationToken.None);

        // Assert
        await action.Should().ThrowAsync<ArgumentException>();
    }
}
