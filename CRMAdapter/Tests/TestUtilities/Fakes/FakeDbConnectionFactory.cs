// <auto-generated>
//  Purpose: Supplies deterministic fake database connections that capture SQL text and parameters for unit tests.
//  What is being validated: Allows adapter unit tests to observe generated SQL, parameterization, and result materialization without touching a real database.
//  Success: Tests receive predictable rows and can assert on command text; failure indicates SQL generation or mapping regressions.
// </auto-generated>
#nullable enable
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

#pragma warning disable CS8765 // Test doubles intentionally mirror Db* signatures without nullability noise.

namespace CRMAdapter.Tests.TestUtilities.Fakes;

/// <summary>
/// Factory helpers that expose deterministic <see cref="DbConnection"/> fakes for adapter unit tests.
/// </summary>
public static class FakeDbConnectionFactory
{
    /// <summary>
    /// Creates a fake connection that will sequentially yield commands configured by the supplied plans.
    /// </summary>
    /// <param name="plans">Command execution plans.</param>
    /// <returns>An in-memory <see cref="DbConnection"/>.</returns>
    public static DbConnection Create(params FakeDbCommandPlan[] plans)
        => new FakeDbConnection(plans ?? Array.Empty<FakeDbCommandPlan>());

    /// <summary>
    /// Creates a plan returning the provided rows and invoking optional assertions.
    /// </summary>
    public static FakeDbCommandPlan Plan(string name, IEnumerable<IDictionary<string, object?>> rows, Action<FakeDbCommand>? assertion = null)
        => new(name, rows, assertion);
}

/// <summary>
/// Represents an expected command execution and materialised result set.
/// </summary>
public sealed class FakeDbCommandPlan
{
    private readonly Func<FakeDbCommand, CancellationToken, Task<DbDataReader>> _executor;

    public FakeDbCommandPlan(string name, IEnumerable<IDictionary<string, object?>> rows, Action<FakeDbCommand>? assertion = null)
    {
        if (rows is null)
        {
            throw new ArgumentNullException(nameof(rows));
        }

        Name = name ?? string.Empty;
        Rows = rows
            .Select((row, index) => row?.ToDictionary(pair => pair.Key, pair => pair.Value, StringComparer.OrdinalIgnoreCase)
                ?? throw new ArgumentException($"Row {index} cannot be null.", nameof(rows)))
            .Select(dictionary => (IReadOnlyDictionary<string, object?>)dictionary)
            .ToArray();

        Assertion = assertion;
        _executor = (command, _) => Task.FromResult<DbDataReader>(new FakeDbDataReader(Rows));
    }

    public FakeDbCommandPlan(string name, Func<FakeDbCommand, CancellationToken, Task<DbDataReader>> executor, Action<FakeDbCommand>? assertion = null)
    {
        _executor = executor ?? throw new ArgumentNullException(nameof(executor));
        Name = name ?? string.Empty;
        Assertion = assertion;
        Rows = Array.Empty<IReadOnlyDictionary<string, object?>>();
    }

    public string Name { get; }

    public IReadOnlyList<IReadOnlyDictionary<string, object?>> Rows { get; }

    public Action<FakeDbCommand>? Assertion { get; }

    internal async Task<DbDataReader> ExecuteAsync(FakeDbCommand command, CancellationToken cancellationToken)
    {
        Assertion?.Invoke(command);
        return await _executor(command, cancellationToken).ConfigureAwait(false);
    }
}

internal sealed class FakeDbConnection : DbConnection
{
    private readonly FakeDbCommandPlan[] _plans;
    private int _index;
    private ConnectionState _state = ConnectionState.Closed;

    public FakeDbConnection(FakeDbCommandPlan[] plans)
    {
        _plans = plans ?? Array.Empty<FakeDbCommandPlan>();
    }

    public override string ConnectionString { get; set; } = "Fake";

    public override string Database => "Fake";

    public override string DataSource => "Fake";

    public override string ServerVersion => "1.0";

    public override ConnectionState State => _state;

    protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel) => throw new NotSupportedException();

    public override void ChangeDatabase(string databaseName) => throw new NotSupportedException();

    public override void Close() => _state = ConnectionState.Closed;

    public override async Task CloseAsync()
    {
        await Task.Yield();
        Close();
    }

    public override void Open()
    {
        _state = ConnectionState.Open;
    }

    public override async Task OpenAsync(CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        await Task.Yield();
        Open();
    }

    protected override DbCommand CreateDbCommand()
    {
        if (_index >= _plans.Length)
        {
            throw new InvalidOperationException("No command plan registered for the requested operation.");
        }

        var command = new FakeDbCommand(_plans[_index], this);
        _index++;
        return command;
    }
}

/// <summary>
/// Minimal <see cref="DbCommand"/> implementation emitting deterministic results.
/// </summary>
public sealed class FakeDbCommand : DbCommand
{
    private readonly FakeDbCommandPlan _plan;
    private readonly FakeDbConnection _connection;
    private readonly FakeDbParameterCollection _parameters = new();

    internal FakeDbCommand(FakeDbCommandPlan plan, FakeDbConnection connection)
    {
        _plan = plan ?? throw new ArgumentNullException(nameof(plan));
        _connection = connection;
    }

    public override string CommandText { get; set; } = string.Empty;

    public override int CommandTimeout { get; set; } = 30;

    public override CommandType CommandType { get; set; } = CommandType.Text;

    public override bool DesignTimeVisible
    {
        get => false;
        set { }
    }

    public override UpdateRowSource UpdatedRowSource { get; set; } = UpdateRowSource.None;

    protected override DbConnection DbConnection
    {
        get => _connection;
        set => throw new NotSupportedException();
    }

    protected override DbParameterCollection DbParameterCollection => _parameters;

    protected override DbTransaction? DbTransaction { get; set; }

    public IReadOnlyCollection<DbParameter> ParametersSnapshot => _parameters.Items;

    public override void Cancel()
    {
    }

    public override int ExecuteNonQuery() => throw new NotSupportedException("Use asynchronous APIs in tests.");

    public override Task<int> ExecuteNonQueryAsync(CancellationToken cancellationToken) => throw new NotSupportedException("Use readers in tests.");

    public override object? ExecuteScalar() => throw new NotSupportedException();

    public override Task<object?> ExecuteScalarAsync(CancellationToken cancellationToken) => throw new NotSupportedException();

    public override void Prepare()
    {
    }

    protected override DbParameter CreateDbParameter() => new FakeDbParameter();

    protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
        => ExecuteDbDataReaderAsync(behavior, CancellationToken.None).GetAwaiter().GetResult();

    protected override async Task<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken)
    {
        return await _plan.ExecuteAsync(this, cancellationToken).ConfigureAwait(false);
    }
}

internal sealed class FakeDbParameter : DbParameter
{
    public override DbType DbType { get; set; } = DbType.String;

    public override ParameterDirection Direction { get; set; } = ParameterDirection.Input;

    public override bool IsNullable { get; set; }

    public override string ParameterName { get; set; } = string.Empty;

    public override string SourceColumn { get; set; } = string.Empty;

    public override object? Value { get; set; }

    public override bool SourceColumnNullMapping { get; set; }

    public override int Size { get; set; }

    public override void ResetDbType()
    {
    }
}

internal sealed class FakeDbParameterCollection : DbParameterCollection
{
    private readonly List<DbParameter> _parameters = new();

    public IReadOnlyCollection<DbParameter> Items => _parameters.AsReadOnly();

    public override int Count => _parameters.Count;

    public override object SyncRoot => ((ICollection)_parameters).SyncRoot;

    public override int Add(object value)
    {
        if (value is not DbParameter parameter)
        {
            throw new ArgumentException("Value must be a DbParameter.", nameof(value));
        }

        _parameters.Add(parameter);
        return _parameters.Count - 1;
    }

    public override void AddRange(Array values)
    {
        foreach (var value in values.Cast<object>())
        {
            Add(value);
        }
    }

    public override void Clear() => _parameters.Clear();

    public override bool Contains(object value)
        => value is DbParameter parameter && _parameters.Contains(parameter);

    public override bool Contains(string value) => _parameters.Any(p => string.Equals(p.ParameterName, value, StringComparison.Ordinal));

    public override void CopyTo(Array array, int index) => ((ICollection)_parameters).CopyTo(array, index);

    public override IEnumerator GetEnumerator() => _parameters.GetEnumerator();

    protected override DbParameter GetParameter(int index) => _parameters[index];

    protected override DbParameter GetParameter(string parameterName)
    {
        var index = IndexOf(parameterName);
        if (index < 0)
        {
            throw new IndexOutOfRangeException($"Parameter '{parameterName}' was not found.");
        }

        return _parameters[index];
    }

    public override int IndexOf(object value)
        => value is DbParameter parameter ? _parameters.IndexOf(parameter) : -1;

    public override int IndexOf(string parameterName)
        => _parameters.FindIndex(parameter => string.Equals(parameter.ParameterName, parameterName, StringComparison.Ordinal));

    public override void Insert(int index, object value)
    {
        if (value is not DbParameter parameter)
        {
            throw new ArgumentException("Value must be a DbParameter.", nameof(value));
        }

        _parameters.Insert(index, parameter);
    }

    public override bool IsFixedSize => false;

    public override bool IsReadOnly => false;

    public override bool IsSynchronized => false;

    public override void Remove(object value)
    {
        if (value is DbParameter parameter)
        {
            _parameters.Remove(parameter);
        }
    }

    public override void RemoveAt(int index) => _parameters.RemoveAt(index);

    public override void RemoveAt(string parameterName)
    {
        var index = IndexOf(parameterName);
        if (index >= 0)
        {
            RemoveAt(index);
        }
    }

    protected override void SetParameter(int index, DbParameter value)
    {
        _parameters[index] = value;
    }

    protected override void SetParameter(string parameterName, DbParameter value)
    {
        var index = IndexOf(parameterName);
        if (index >= 0)
        {
            _parameters[index] = value;
        }
        else
        {
            _parameters.Add(value);
        }
    }
}

internal sealed class FakeDbDataReader : DbDataReader
{
    private readonly IReadOnlyList<IReadOnlyDictionary<string, object?>> _rows;
    private int _index = -1;

    public FakeDbDataReader(IReadOnlyList<IReadOnlyDictionary<string, object?>> rows)
    {
        _rows = rows ?? throw new ArgumentNullException(nameof(rows));
    }

    public override int FieldCount => _rows.Count == 0 ? 0 : _rows[0].Count;

    public override bool HasRows => _rows.Count > 0;

    public override object this[int ordinal] => GetValue(ordinal);

    public override object this[string name] => GetValue(GetOrdinal(name));

    public override int Depth => 0;

    public override bool IsClosed => false;

    public override int RecordsAffected => -1;

    public override bool GetBoolean(int ordinal) => (bool)GetValue(ordinal);

    public override byte GetByte(int ordinal) => (byte)GetValue(ordinal);

    public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length) => throw new NotSupportedException();

    public override char GetChar(int ordinal) => (char)GetValue(ordinal);

    public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length) => throw new NotSupportedException();

    public override string GetDataTypeName(int ordinal) => GetValue(ordinal).GetType().Name;

    public override DateTime GetDateTime(int ordinal) => (DateTime)GetValue(ordinal);

    public override decimal GetDecimal(int ordinal) => (decimal)GetValue(ordinal);

    public override double GetDouble(int ordinal) => Convert.ToDouble(GetValue(ordinal));

    public override Type GetFieldType(int ordinal) => GetValue(ordinal).GetType();

    public override float GetFloat(int ordinal) => Convert.ToSingle(GetValue(ordinal));

    public override Guid GetGuid(int ordinal) => (Guid)GetValue(ordinal);

    public override short GetInt16(int ordinal) => Convert.ToInt16(GetValue(ordinal));

    public override int GetInt32(int ordinal) => Convert.ToInt32(GetValue(ordinal));

    public override long GetInt64(int ordinal) => Convert.ToInt64(GetValue(ordinal));

    public override string GetName(int ordinal)
    {
        if (_rows.Count == 0)
        {
            throw new IndexOutOfRangeException("No rows available.");
        }

        return _rows[0].Keys.ElementAt(ordinal);
    }

    public override int GetOrdinal(string name)
    {
        if (_rows.Count == 0)
        {
            throw new IndexOutOfRangeException("No rows available.");
        }

        var keys = _rows[0].Keys.ToList();
        var index = keys.FindIndex(key => string.Equals(key, name, StringComparison.OrdinalIgnoreCase));
        if (index < 0)
        {
            throw new IndexOutOfRangeException($"Field '{name}' was not found.");
        }

        return index;
    }

    public override string GetString(int ordinal)
    {
        var value = GetValue(ordinal);
        return value is DBNull ? string.Empty : Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;
    }

    public override object GetValue(int ordinal)
    {
        if (_index < 0 || _index >= _rows.Count)
        {
            throw new InvalidOperationException("Reader is not positioned on a valid row.");
        }

        var value = _rows[_index].Values.ElementAt(ordinal);
        return value ?? DBNull.Value;
    }

    public override int GetValues(object[] values)
    {
        if (_index < 0 || _index >= _rows.Count)
        {
            return 0;
        }

        var rowValues = _rows[_index].Values.ToArray();
        var copyLength = Math.Min(values.Length, rowValues.Length);
        Array.Copy(rowValues, values, copyLength);
        return copyLength;
    }

    public override bool IsDBNull(int ordinal)
    {
        if (_index < 0 || _index >= _rows.Count)
        {
            throw new InvalidOperationException("Reader is not positioned on a valid row.");
        }

        return _rows[_index].Values.ElementAt(ordinal) is null;
    }

    public override bool NextResult() => false;

    public override bool Read()
    {
        _index++;
        return _index < _rows.Count;
    }

    public override Task<bool> ReadAsync(CancellationToken cancellationToken)
        => Task.FromResult(Read());

    public override Task<bool> NextResultAsync(CancellationToken cancellationToken) => Task.FromResult(false);

    public override IEnumerator GetEnumerator()
    {
        while (Read())
        {
            yield return this;
        }
    }
}
